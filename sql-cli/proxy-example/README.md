# SQL-CLI to KDB+ Proxy Example

This demonstrates how sql-cli could work in "proxy mode" to translate SQL queries to kdb+/q queries using the AST and tokens generated by the Rust parser.

## Architecture

```
┌─────────────┐     SQL Query      ┌──────────────┐      q Query       ┌─────────┐
│   sql-cli   │ ──────────────────> │  C# Proxy    │ ─────────────────> │  kdb+   │
│   (Rust)    │   + AST + Tokens    │  REST API    │                    │ Server  │
└─────────────┘                     └──────────────┘                    └─────────┘
       ↑                                    │                                 │
       │              JSON Results          │           q Results            │
       └────────────────────────────────────┴────────────────────────────────┘
```

## How It Works

1. **sql-cli** parses the SQL query and generates:
   - Tokenized output
   - AST (Abstract Syntax Tree)
   - Query metadata

2. **Proxy API** receives the request and:
   - Translates SQL AST to q query syntax
   - Handles type conversions (DateTime, strings, etc.)
   - Maps SQL operations to q equivalents

3. **kdb+ Server** executes the q query and returns results

4. **Proxy API** transforms results back to sql-cli JSON format

## Translation Examples

### Example 1: Complex WHERE clause
```sql
-- SQL Input
SELECT * FROM trades 
WHERE confirmationStatus.StartsWith('pend') 
  AND commission BETWEEN 30 AND 100 
  AND createdDate > DateTime(2025,07,10)

-- AST Tree
AND
  AND
    STARTS_WITH_IGNORE_CASE(confirmationStatus, "pend")
    BETWEEN(commission, Number(30.0), Number(100.0))
  GREATER_THAN(createdDate, String("2025-07-10 00:00:00"))

-- Translated q Query
select from trades where 
  (lower[confirmationStatus] like lower["pend*"]),
  (commission within 30 100),
  (createdDate>2025.07.10)
```

### Example 2: Case-Insensitive Equality
```sql
-- SQL Input
SELECT * FROM trades WHERE status = 'pending'

-- With case_insensitive = true
-- Translated q Query
select from trades where (lower[status]=lower[`pending])
```

### Example 3: IN Clause
```sql
-- SQL Input
SELECT * FROM trades WHERE status IN ('pending', 'confirmed')

-- Translated q Query
select from trades where (status in (`pending;`confirmed))
```

## Key Translation Rules

### SQL to q Mappings

| SQL Operation | q Equivalent | Notes |
|--------------|--------------|-------|
| `=` | `=` | With backtick for symbols |
| `!=` | `<>` | Not equal |
| `BETWEEN x AND y` | `within x y` | Range check |
| `IN (a,b,c)` | `in (a;b;c)` | List membership |
| `LIKE 'prefix%'` | `like "prefix*"` | Pattern matching |
| `.StartsWith()` | `like "prefix*"` | String prefix |
| `.Contains()` | `in` (substring) | String search |
| `DateTime(Y,M,D)` | `Y.M.D` | Date format |

### Case-Insensitive Operations

When `case_insensitive = true`:
- String comparisons use `lower[]` function
- Example: `lower[column]=lower[value]`

## API Endpoints

### Execute Query
```http
POST /api/query/execute
Content-Type: application/json

{
  "sqlQuery": "SELECT * FROM trades WHERE ...",
  "astTree": { /* AST JSON */ },
  "tokens": ["SELECT", "STAR", ...],
  "caseInsensitive": true
}
```

Response:
```json
{
  "data": [
    {"id": 1, "status": "pending", ...},
    {"id": 2, "status": "confirmed", ...}
  ],
  "count": 2,
  "query": {
    "select": ["*"],
    "whereClause": "...",
    "orderBy": null
  },
  "source": "kdb",
  "table": "trades",
  "cached": false
}
```

### Get Schema
```http
GET /api/query/schema/trades
```

Response:
```json
{
  "tableName": "trades",
  "columns": [
    {"name": "id", "type": "long", "isNullable": false},
    {"name": "status", "type": "symbol", "isNullable": true},
    {"name": "createdDate", "type": "datetime", "isNullable": true}
  ]
}
```

## Implementation Notes

1. **Type Handling**: The proxy handles type conversions between SQL types and q types
2. **Performance**: Complex queries are translated to efficient q queries that leverage kdb+'s columnar storage
3. **Error Handling**: Translation errors are caught and returned with helpful messages
4. **Extensibility**: New SQL functions can be mapped to q equivalents by extending the translator

## Testing the Translation

Run the demo:
```csharp
AdvancedQTranslator.DemoComplexTranslation();
```

This will show various SQL to q translations.

## Future Enhancements

1. **Aggregations**: Support for GROUP BY, SUM, AVG, etc.
2. **Joins**: Multi-table queries
3. **Time-series functions**: Leverage kdb+'s time-series capabilities
4. **Streaming**: Real-time query subscriptions
5. **Query optimization**: Analyze AST to optimize q query generation

## Configuration in sql-cli

To use proxy mode, sql-cli would need configuration like:
```toml
[proxy]
enabled = true
endpoint = "http://localhost:5000/api/query"
auth_token = "..."
timeout_ms = 30000
```

Then queries would automatically route through the proxy when targeting kdb+ tables.